<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[亿级流量缓存架构相关笔记]]></title>
    <url>%2F2020%2F09%2F07%2F%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84%E7%AF%87%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[分布式锁相关]]></title>
    <url>%2F2020%2F07%2F16%2F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[分布式锁：在分布式环境下，执行事务的线程存在于不同的网络服务器中，实现在分布式网络下的线程协同操作。 分布式死锁解决方案：死锁检测和超时方法。 超时方法：超时方式是在创建分布式线程的时候，对每个线程都设置一个超时时间 死锁检测：可以理解为一个运行在各个服务器系统上的线程或方法，该方法专门用来探索发现应用服务上的线程是否发生了死锁。如果发生死锁，就会触发相应的预设处理方案 Zk中锁的实现： 排它锁：排他锁 共享锁：只对数据事务的写操作加锁。在ZK中实现只对同一个数据事务使用两个数据节点，按照读写区分数据事务的读W写R操作。 ​]]></content>
      <tags>
        <tag>分布式死锁、</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis 命令]]></title>
    <url>%2F2020%2F06%2F16%2Fredis-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[value 数据类型包含 string、hash、 list、 set、 sorted set（Zset）互联网公司一般使用场景1. String : 缓存、限流、计数器、分布式锁、分布式session 2. Hash : 存储用户信息、用户主页访问量、组合查询 3. List : 微博关注人时间轴列表、简单队列 4. Set : 赞、踩、好友关系、标签 5. Zset : 排行榜 key命令keys * 获取所有的key select 0 选择第一个库 move myString 1 将当前的数据库key移动到某个数据库,目标库有，则不能移动 flush db 清除指定库 randomkey 随机key type key 类型 set key1 value1 设置key get key1 获取key mset key1 value1 key2 value2 key3 value3 mget key1 key2 key3 del key1 删除key exists key 判断是否存在key expire key 10 10过期 pexpire key 1000 毫秒 persist key 删除过期时间 string命令set name cxx get name getrange name 0 -1 字符串分段 getset name new_cxx 设置值，返回旧值 mset key1 key2 批量设置 mget key1 key2 批量获取 setnx key value 不存在就插入（not exists） setex key time value 过期时间（expire） setrange key index value 从index开始替换value incr age 递增 incrby age 10 递增 decr age 递减 decrby age 10 递减 incrbyfloat 增减浮点数 append 追加 strlen 长度 getbit/setbit/bitcount/bitop 位操作 应用场景1. String常用于保存单个字符串或Json字符串数据 2. 因String是二进制安全的，可以把图片文件的内容作为字符串保存 3. 计数器（常规key-value缓存应用，常规技术：微博数，粉丝数） hash命令hset myhash name cxx hget myhash name hmset myhash name cxx age 25 note &quot;i am notes&quot; hmget myhash name age note hgetall myhash 获取所有的 hexists myhash name 是否存在 hsetnx myhash score 100 设置不存在的 hincrby myhash id 1 递增 hdel myhash name 删除 hkeys myhash 只取key hvals myhash 只取value hlen myhash 长度 应用场景1. 常用于存储一个对象 2. 因String是二进制安全的，可以把图片文件的内容作为字符串保存 3. 计数器（常规key-value缓存应用，常规技术：微博数，粉丝数） list命令lpush mylist a b c 左插入 rpush mylist x y z 右插入 lrange mylist 0 -1 数据集合 lpop mylist 弹出元素 rpop mylist 弹出元素 llen mylist 长度 lrem mylist count value 删除 lindex mylist 2 指定索引的值 lset mylist 2 n 索引设值 ltrim mylist 0 4 删除key linsert mylist before a 插入 linsert mylist after a 插入 rpoplpush list list2 转移列表的数据 set命令sadd myset redis smembers myset 数据集合 srem myset set1 删除 sismember myset set1 判断元素是否在集合中 scard key_name 个数 sdiff | sinter | sunion 操作：集合间运算：差集 | 交集 | 并集 srandmember 随机获取集合中的元素 spop 从集合中弹出一个元素 zset命令zadd zset 1 one zadd zset 2 two zadd zset 3 three zincrby zset 1 one 增长分数 zscore zset two 获取分数 zrange zset 0 -1 withscores 范围值 zrangebyscore zset 10 25 withscores 指定范围的值 zrangebyscore zset 10 25 withscores limit 1 2 分页 Zrevrangebyscore zset 10 25 withscores 指定范围的值 zcard zset 元素数量 Zcount zset 获得指定分数范围内的元素个数 Zrem zset one two 删除一个或多个元素 Zremrangebyrank zset 0 1 按照排名范围删除元素 Zremrangebyscore zset 0 1 按照分数范围删除元素 Zrank zset 0 -1 分数最小的元素排名为0 Zrevrank zset 0 -1 分数最大的元素排名为0 Zinterstore zunionstore rank:last_week 7 rank:20150323 rank:20150324 rank:20150325 weights 1 1 1 1 1 1 1 ​ 排序命令sort mylist 排序 sort mylist alpha desc limit 0 2 字母排序 sort list by it:* desc by命令 sort list by it:* desc get it:* get参数 sort list by it:* desc get it:* store sorc:result sort命令之store参数：表示把sort查询的结果集保存起来 订阅与发布命令订阅频道：subscribe chat1 发布消息：publish chat1 &quot;hell0 ni hao&quot; 查看频道：pubsub channels 查看某个频道的订阅者数量: pubsub numsub chat1 退订指定频道： unsubscrible chat1 , punsubscribe java.* 订阅一组频道： psubscribe java.* redis事务 隔离性，原子性， 步骤： 开始事务，执行命令，提交事务 multi //开启事务 sadd myset a b c sadd myset e f g lpush mylist aa bb cc lpush mylist dd ff gg 服务器管理相关命令dump.rdb appendonly.aof //BgRewriteAof 异步执行一个aop(appendOnly file)文件重写 会创建当前一个AOF文件体积的优化版本 //BgSave 后台异步保存数据到磁盘，会在当前目录下创建文件dump.rdb //save同步保存数据到磁盘，会阻塞主进程，别的客户端无法连接 //client kill 关闭客户端连接 //client list 列出所有的客户端 //给客户端设置一个名称 client setname myclient1 client getname config get port //configRewrite 对redis的配置文件进行改写 rdbsave 900 1 save 300 10 save 60 10000 aop备份处理appendonly yes 开启持久化 appendfsync everysec 每秒备份一次 其他命令bgsave异步保存数据到磁盘（快照保存） lastsave返回上次成功保存到磁盘的unix的时间戳 shutdown同步保存到服务器并关闭redis服务器 bgrewriteaof文件压缩处理（命令）]]></content>
      <tags>
        <tag>redis常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis简介]]></title>
    <url>%2F2020%2F06%2F14%2FRedis%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[C语言编写，完全开源免费，遵循BSD协议（伯克利软件发行版），高性能的NoSQL(非关系型数据库) key-value数1.0 出现原因分析： High performance对数据库高并发读写的需求 Hug storage 对海量数据的高效率存储和访问的需求 High Scalabilty &amp;&amp; High Availability 对数据库的高可扩展性和高可用性的需求 2.0 NoSQL类别 类别 优点 缺点 典型应用 数据模型 相关产品 key-value 存储数据库 快速查询 存储的数据缺少结构化 内容缓存，主要用于处理大量数据的高访问负载 一系列的键值对 Redis 列存储数据库 查找速度快，可扩展性强，更容易进行分布式扩展 功能相对局限 分布式的文件系统 以列簇式存储，将同一列数据存在一起 hbase 文档型数据库 数据结构要求不严格 查询性能不高，并缺乏统一的查询语法 web 应用（与key-value类似，value是结构化的） 一系列键值对 MongoDB 图形数据库 利用图结构相关算法 需要对整个图做计算才能得出结果，不容易做分布式的集群方案 社交网络 图结构 Neo4J 3.0 Redis特点优点 高性能官方测试11W次/s读操作，8w次/s写操作 数据类型丰富 支持String,Set,Hash,List及Ordered Set 类型操作 丰富特性 支持publish/subscribe,通知，key过期等 高速读写 Redis使用自己实现的分离器，代码量短，没有使用lock效率高 原子性 所有操作都是原子性的，单个操作是原子性的；多个操作通过MULTI和EXEC实现事务原子性操作。 缺点 持久化 Redis直接将数据存储到内存中，要将数据保存到磁盘上有两种持久化方式。RDB/AOF,后期有专题讲解。 内存占用过高 3.0 Redis安装 3.0.1 采用C语言开发，Linux系统下需要编译，需要有GCC环境 $ yum -y install gcc automake autoconf libtool make 注意：运行yum时出现/var/run/yum.pid已被锁定，pid为XXXX正在运行的问题解决 $ rm -f /var/run/yum.pid 3.0.2 安装$ wget http://download.redis.io/releases/redis-5.0.7.tar.gz $ tar xzf redis-6.0.5.tar.gz -C 指定解压目录 $ cd redis-5.0.7 $ make 3.0.3 单机服务启动$ src/redis-server 3.0.4 客户端启动及简单功能使用方式一 $ src/redis-cli redis&gt; set foo bar OK redis&gt; get foo &quot;bar&quot; 方式二：客户端命令语法 $ src/redis-cli -h ip地址 -p 端口号 -a 密码（设置的话） redis&gt; set foo bar OK redis&gt; get foo &quot;bar&quot; 4.0 Redis内存维护策略 4.0.1 设置数据超时时间--常用方式 expire key time (s为单位) --字符串 setex(String key，int time ,String value ) 除字符串外，都需要以expire来设置过期时间 未设置则默认为永不过期 设置后取消过期时间设置：persist key4.0.2 LRU算法动态删除数据 内存管理的一种页面置换算法，存在内存中但不使用的数据（内存块）叫做LRU，操作系统会移出LRU数据来加载其它数据 volatile-lru: 设定超时时间的数据中，删除最不常使用的数据 allkeys-lru: 查询所有的key中最近最不常使用的数据删除（使用广泛）]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于HashMap的设计及优化问题]]></title>
    <url>%2F2020%2F05%2F27%2F%E5%85%B3%E4%BA%8EHashMap%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8F%8A%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[JDK1.8中对hash算法和寻址算法的优化- 优化一 hash算法： hash值的位运算+异或运算（^）保证低位二进制数据包含高低位数据的特征，一定程度上避免后续运算hash碰撞而计算出相同的数组下标- 优化二 寻址算法： ``` 寻址时对hash值取模性能较低，改用位与运算提高性能。hash &amp;(n-1)（优化后所得哈希值和n-1做与运算--n数组长度为2的n次幂）``` ##### HashMap如何解决hash碰撞问题 - ###### 问题原因： map.get()、map.set()都是算出key的hash值，到数组中寻址，放入或者取出key-value对，在寻址时，根据键算出的hash值与（n-1）^keyHash（相当于取模，位运算提高性能）寻址确定。该动作可能会产生hash冲突，不同键值对运算后可能得到相同的数组地址。 - ###### 解决方式 存放数据时，在寻址后具有相同位置的地方挂一个链表存放元素；取数据定位到数组时若存在链表则遍历链表，查找对应的key取值。 -- 链表长度过长时，遍历时间复杂度为O(n)；链表达到一定长度后，会将链表转换为红黑树，红黑树遍历查找一个元素的时间复杂度为O（logn）,性能通链表。 ##### HashMap的扩容 - ###### rehash双倍扩容 ##### ConcurrentHashMap实现线程安全的底层原理 - ######]]></content>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库和Reids缓存的数据一致性问题思考]]></title>
    <url>%2F2020%2F05%2F25%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CReids%E7%BC%93%E5%AD%98%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[在这里，我们讨论三种更新策略： 先更新缓存，再更新数据库 先更新数据库，再更新缓存 先删除缓存，再更新数据库 先更新数据库，再删除缓存 第一种，先更新缓存，再更新数据库问题：更新缓存成功，更新数据库失败，导致数据不一致。 第二种，先更新数据库，再更新缓存问题： 1、A更新数据库 2、B更新数据库 3、B写入缓存 4、A写入缓存 出现数据不一致。 第二种，先删除缓存，再更新数据库。网络上的方案 延时双删 1、先删除缓存 2、更新数据库 3、等待一会再删除缓存 问题之一：延时双删，演变成了：先更新数据库，再删除缓存。。。。 比如： 1、A删除缓存 2、B查询数据库获取旧值 3、B更新了缓存 4、A更新数据库 5、A延时删缓存 1～3步执行后，数据库和缓存是一致的，成了开支执行前的状态，相当于没执行。 4～5步：先更新数据库，再删缓存。 所以延时双删演变成了：先更新数据库，再删除缓存。问题还是没解决。。。 为什么？假设，此时，在第4步执行之前，又来了个查询C，C查询到旧值。第6步：C将旧值插入缓存。此时出现缓存和数据库不一致。 延时并不能解决：C插入缓存的操作在第5步后面执行，比如C遇到网络问题、GC问题等。当然这是小概率，但并不代表不存在。 当然，延时越长，这个问题越能规避。如果业务需求不是非常严格，是可以忽略的。 第三种，先更新数据库，再删除缓存问题：上面C的查询，已经说明问题了。 出现数据不一致的概率，比较小。采取这个方案，取决于业务需求。 终极方案 真正靠谱的方案：将访问操作串行化 先删缓存，将更新数据库的操作放进有序队列中 从缓存查不到的查询操作，都进入有序队列 会面临的问题： 读请求积压，大量超时，导致数据库的压力：限流、熔断 如何避免大量请求积压：将队列水平拆分，提高并行度。 保证相同请求路由正确。]]></content>
      <tags>
        <tag>redis和mysql数据一致性的问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试考察能力和技术方向]]></title>
    <url>%2F2020%2F05%2F24%2F%E9%9D%A2%E8%AF%95%E8%80%83%E5%AF%9F%E8%83%BD%E5%8A%9B%E5%92%8C%E6%8A%80%E6%9C%AF%E6%96%B9%E5%90%91%2F</url>
    <content type="text"><![CDATA[​ 观看《 互联网Java工程师面试突击（第三季） 》时发现，缺少对于工作面试考察的层面和技术体系缺乏一个完整的认识和总结。借此篇博客做一个浅略的总结和思考，希望对自己的职业发展有些帮助。 面试考察受试者的方面一、技术层面： 基础知识​ 数据结构和算法、网络协议、通信协议、计算机组成原理、操作系统 技术广度​ 分布式、微服务、缓存、消息中间件、服务治理、分库分表、消息检索、数据库、 技术深度​ 源码阅读、项目深度、开源社区 项目经验​ 2C、2B、政企、金融、电信、移动互联网、CURD 架构能力​ 设计过的架构数据量 二、综合角度 管理能力 学历 履历 软素质​ 沟通能力、表达能力、团队协作、性格、价值观等]]></content>
      <tags>
        <tag>面试能力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA 插件篇]]></title>
    <url>%2F2020%2F05%2F11%2FIDEA-%E6%8F%92%E4%BB%B6%E7%AF%87%2F</url>
    <content type="text"><![CDATA[​ 插件名 功能 备注 IDE Features Trainer 在 IDE 中以交互方式学习IDEA最常用的快捷方式和最基本功能 无、编辑器中Learn选项 GsonFormat JSON格式转换 Windows: Ctrl + Enter; Mac: Command + Enter ) RoboPOJOGenerator JSon转类对象 Codota 代码智能提示 https://www.codota.com/code根据代码关键字搜索相关代码示例 Key Promoter X 操作时快捷键方式建议 无 Translation 在线google/baidu/youdao翻译 command+ctrl+u(mac)/ shift+ctrl+y(win/linux)]]></content>
      <tags>
        <tag>IDEA 插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot中过滤器和拦截器]]></title>
    <url>%2F2020%2F04%2F29%2Fspringboot%E4%B8%AD%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[过滤器1.定义过滤器package cn.dumboj.filter; import javax.servlet.*; import java.io.IOException; import java.util.Date; /** * @Description 过滤器执行耗时---接口实现 * @return * @Author dumboj * @Date 2020/4/29 11:11 * @Version 1.0 */ //@Component //@WebFilter(urlPatterns = &quot;/*&quot;) public class AnnotationTimeFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(&quot;filter init....&quot;); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(&quot;start filter&quot;); long startTime = new Date().getTime(); chain.doFilter(request,response); System.out.println(&quot;过滤器耗时：&quot; + (new Date().getTime() - startTime)); System.out.println(&quot;过滤器执行完成&quot;); &#125; @Override public void destroy() &#123; System.out.println(&quot;销毁过滤器&quot;); &#125; &#125; 2.过滤条件设置和过滤器注入方式一：注解注入（推荐）​ /** 配置方式一：注解方式 * &#123;@link @Component&#125; bean注入容器 * &#123;@link @WebFilter(urlPatterns = &quot;/*&quot;)&#125; * urlPatterns 配置哪些请求可以进入过滤器，/*表示所有请求 */ @Component @WebFilter(urlPatterns = &quot;/*&quot;) public class AnnotationTimeFilter implements Filter &#123; ... ... &#125; 3.过滤条件设置和过滤器注入方式二：过滤器注册package cn.dumboj.filter; import org.springframework.boot.web.servlet.FilterRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.servlet.Filter; import java.util.ArrayList; /** * @Description 过滤器质性耗时--注册器实现 * @return * @Author dumboj * @Date 2020/4/29 14:10 * @Version 1.0 */ @Configuration public class RegistraTimeFilter &#123; //筑造器注入 @Bean public FilterRegistrationBean registrationBeanFilter()&#123; FilterRegistrationBean&lt;Filter&gt; filterRegistrationBean = new FilterRegistrationBean&lt;&gt;(); AnnotationTimeFilter timeFilter = new AnnotationTimeFilter(); //设置具体过滤器实现 filterRegistrationBean.setFilter(timeFilter); //设置过滤条件 ArrayList&lt;String&gt; urlList = new ArrayList&lt;&gt;(); urlList.add(&quot;/*&quot;); filterRegistrationBean.setUrlPatterns(urlList); return filterRegistrationBean; &#125; &#125; 拦截器Springboot中定义拦截器， 条件一：实现org.springframework.web.servlet.HandlerInterceptor接口 package cn.dumboj.interceptor; import org.springframework.stereotype.Component; import org.springframework.web.method.HandlerMethod; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.util.Date; /** * @Description 自定义拦截器 * @return * @Author dumboj * @Date 2020/4/29 19:15 * @Version 1.0 */ @Component public class CustomerInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;拦截预处理：&quot;); request.setAttribute(&quot;startTime&quot;,new Date().getTime()); String beanName = (((HandlerMethod) handler)).getBean().getClass().getName(); String methodName = (((HandlerMethod) handler)).getMethod().getName(); System.out.println(&quot;类方法：&quot; + beanName + &quot;.&quot; + methodName); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;开始处理拦截&quot;); Long startTime = (Long) request.getAttribute(&quot;startTime&quot;); System.out.println(&quot;拦截器postHandle()执行完耗时：&quot;+(new Date().getTime()-startTime)); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;处理拦截后&quot;); Long startTime = (Long) request.getAttribute(&quot;startTime&quot;); System.out.println(&quot;拦截器 afterCompletion ()执行完耗时：&quot;+(new Date().getTime()-startTime)); System.out.println(&quot;异常信息:&quot;+ex); &#125; &#125; HandlerInterceptor接口中三个方法实现： ​ preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) ​ 处理拦截之前执行 postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) ​ 被拦截的方法没有抛出异常时才执行 afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) ​ 无论被拦截方法是否抛出异常都会执行 条件二： 自定义拦截器类上加入@Component注解； 添加配置类,实现WebMvcConfigurer接口，并重写addInterceptors（），注册自定义过滤器 package cn.dumboj.interceptor; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter; import javax.annotation.Resource; /** * @Description 注册拦截器 * @return * @Author dumboj * @Date 2020/4/30 16:14 * @Version 1.0 */ @Configuration public class InterceptConfig implements WebMvcConfigurer &#123; /** * Add Spring MVC lifecycle interceptors for pre- and post-processing of * controller method invocations and resource handler requests. * Interceptors can be registered to apply to all requests or be limited * to a subset of URL patterns. * * &#123;@link WebMvcConfigurerAdapter&#125; * as of 5.0 &#123;@link WebMvcConfigurer&#125; has default methods (made * * possible by a Java 8 baseline) * @param registry */ @Resource private CustomerInterceptor customerInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(customerInterceptor); &#125; &#125; ​]]></content>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot异常处理]]></title>
    <url>%2F2020%2F04%2F28%2Fspringboot%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[1.默认异常处理​ Spring Boot对异常的处理有一套默认的机制：当应用中产生异常时，Spring Boot根据发送请求头中的accept是否包含text/html来分别返回不同的响应信息。当从浏览器地址栏中访问应用接口时，请求头中的accept便会包含text/html信息，产生异常时，Spring Boot通过org.springframework.web.servlet.ModelAndView对象来装载异常信息，并以HTML的格式返回；而当从客户端访问应用接口产生异常时（客户端访问时，请求头中的accept不包含text/html），Spring Boot则以JSON的格式返回异常信息。 ​ package cn.dumboj.controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; /** * @Description springboot默认异常信息处理 * @return * @Author dumboj * @Date 2020/4/28 10:37 * @Version 1.0 */ @RestController @RequestMapping(&quot;exception&quot;) public class ExceptionController &#123; @GetMapping(&quot;/demo/&#123;id&#125;&quot;) public void get(@PathVariable String id) &#123; throw new RuntimeException(&quot;user not exist&quot;); &#125; &#125; 附：源码过程分析，查看org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController类 errorHtml和error方法的请求地址和方法是一样的，唯一的区别就是errorHtml通过produces = &#123;&quot;text/html&quot;&#125;判断请求头的accpet属性中是否包含text/html 2.自定义异常处理 自定义异常处理类，继承RuntimeException package cn.dumboj.customerexception; /** * @param * @Description 自定义异常类 * @return * @Author dumboj * @Date 2020/4/28 16:36 * @Version 1.0 */ public class ExceptionDemo extends RuntimeException&#123; private String id ; public ExceptionDemo (String id)&#123; super(&quot;this is a customer Exception&quot;); this.id = id; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; &#125; 定义处理自定义异常的Handler package cn.dumboj.customerexception; import org.springframework.http.HttpStatus; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.bind.annotation.ResponseStatus; import java.util.HashMap; import java.util.Map; /** * @param * @Description 自定义异常处理类 * @return * @Author dumboj * @Date 2020/4/28 16:41 * @Version 1.0 */ @ControllerAdvice public class ExceptionControllerHandler &#123; /* * @Description 处理异常 * * @param * @ExceptionHandler 指定要处理的异常类型 * @ResponseStatus 异常处理方法返回的HTTP状态码 * HttpStatus 异常类型枚举 * @Return * @Author dumboj * @Date 2020/4/28 16:45 **/ @ExceptionHandler(ExceptionDemo.class) @ResponseBody @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) public Map&lt;String ,Object&gt; handerExceptionDemo(ExceptionDemo demo)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;id&quot;,demo.getId()); map.put(&quot;message&quot;,demo.getMessage()); return map; &#125; &#125; 测试自定义异常的使用 package cn.dumboj.customerexception; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; /** * @Description 测试自定义异常 * @return * @Author dumboj * @Date 2020/4/28 17:06 * @Version 1.0 */ @RestController() public class ExceptionTestController &#123; @RequestMapping(&quot;/customer/&#123;id&#125;&quot;) public void testCustomerEx(@PathVariable String id)&#123; throw new ExceptionDemo(id); &#125; &#125;]]></content>
      <tags>
        <tag>Springboot 异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot 项目打包成war包和jar包]]></title>
    <url>%2F2020%2F04%2F26%2FSpringboot-%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E6%88%90war%E5%8C%85%E5%92%8Cjar%E5%8C%85%2F</url>
    <content type="text"><![CDATA[1.pom.xml文件配置 标签名称 war jar war jar org.springframework.boot spring-boot-starter-tomcat provided org.springframework.boot spring-boot-starter-tomcat provided 项目名（类似于server.context-path=****） org.springframework.boot spring-boot-maven-plugin 启动类名称 2.添加启动类ServletInitializer/** * @param * @Description 添加启动类ServletInitializer * @return * @Author dumboj * @Date 2020/4/26 19:15 * @Version 1.0 */ public class ServletInitializer extends SpringBootServletInitializer &#123; /** * Configure the application. Normally all you would need to do is to add sources * (e.g. config classes) because other settings have sensible defaults. You might * choose (for instance) to add default command line arguments, or set an active * Spring profile. * * @param builder a builder for the application context * @return the application builder * @see SpringApplicationBuilder */ @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123; return builder.sources(SpringbootDevtoolsApplication.class); &#125; &#125; 3.打包idea中maven下对应项目 Lifecycle中 clean package,则可在target目录下生产相应的jar包和war包]]></content>
      <tags>
        <tag>springboot 打包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 警告抑制]]></title>
    <url>%2F2020%2F04%2F21%2FJava-%E8%AD%A6%E5%91%8A%E6%8A%91%E5%88%B6%2F</url>
    <content type="text"><![CDATA[@SuppressWarnings 注解目标为类、字段、函数、函数入参、构造函数和函数的局部变量。而家建议注解应声明在最接近警告发生的位置。 关键字 用途 all to suppress all warnings boxing to suppress warnings relative to boxing/unboxing operations cast to suppress warnings relative to cast operations dep-ann to suppress warnings relative to deprecated annotation deprecation to suppress warnings relative to deprecation fallthrough to suppress warnings relative to missing breaks in switch statements finally to suppress warnings relative to finally block that don’t return hiding to suppress warnings relative to locals that hide variable incomplete-switch to suppress warnings relative to missing entries in a switch statement (enum case) nls to suppress warnings relative to non-nls string literals null to suppress warnings relative to null analysis rawtypes to suppress warnings relative to un-specific types when using generics on class params restriction to suppress warnings relative to usage of discouraged or forbidden references serial to suppress warnings relative to missing serialVersionUID field for a serializable class static-access o suppress warnings relative to incorrect static access synthetic-access to suppress warnings relative to unoptimized access from inner classes unchecked to suppress warnings relative to unchecked operations unqualified-field-access to suppress warnings relative to field access unqualified unused to suppress warnings relative to unused code]]></content>
      <tags>
        <tag>SuppressWarnings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES单元测试问题小记1]]></title>
    <url>%2F2020%2F04%2F02%2FES%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[问题描述：Window 搭建完Elasticseach 环境，使用localhost 本机都能够正常访问Elasticsearch 环境，使用Springboot +集成elasticsearch 提示如下错误信息：NoNodeAvailableException[None of the configured nodes are available1.相关代码：单元测试package cn.dumboj.springbootes; import cn.dumboj.springbootes.entity.ES.ESCoreDict; import cn.dumboj.springbootes.repository.ES.ESCoreDictRepository; import org.junit.jupiter.api.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; import javax.swing.*; import java.util.Iterator; import java.util.List; @RunWith(SpringRunner.class) @SpringBootTest class SpringbootEsApplicationTests &#123; @Autowired ESCoreDictRepository esCoreDictRepository; @Test public void testEs()&#123; Iterable&lt;ESCoreDict&gt; all = esCoreDictRepository.findAll(); Iterator&lt;ESCoreDict&gt; iterator = all.iterator(); if (iterator.hasNext()) System.out.println(&quot;-----------&quot;+iterator.next().getName()); &#125; &#125; ESRepository代码public interface ESCoreDictRepository extends ElasticsearchRepository&lt;ESCoreDict,Integer&gt; &#123; &#125; ES+JPA properties项目文件配置#JPA配置相关 spring.jpa.database-platform=org.hibernate.dialect.MySQLDialect #ES spring.data.elasticsearch.cluster-nodes=127.0.0.1:9300 spring.data.elasticsearch.cluster-name=my-application 2.单元测试​ ES6.3.2 windows X64 本地环境启动并 运行单元测试。 Exception message:配置文件中没有可以使用的节点 3.解决方式打开并修改本地ES安装目录下/config/elasticsearch.yml文件参数（默认注释） 参数 配置 cluster.name: my-application network.host: 127.0.0.1 http.port: 9200 4.重启ES服务，单元测试启动成功。]]></content>
      <tags>
        <tag>ES6.3.2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云服务器RedisCluste搭建]]></title>
    <url>%2F2020%2F03%2F27%2F%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8RedisCluste%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"></content>
      <categories>
        <category>-centos -RedisCluster -阿里云</category>
      </categories>
      <tags>
        <tag>-RedisCluster</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux服务器单机Redis安装配置]]></title>
    <url>%2F2020%2F03%2F10%2FLinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8D%95%E6%9C%BARedis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[backing day]]></title>
    <url>%2F2020%2F03%2F09%2Fbacking-day%2F</url>
    <content type="text"><![CDATA[​ 嘘~]]></content>
  </entry>
  <entry>
    <title><![CDATA[elaticsearch学习一]]></title>
    <url>%2F2020%2F01%2F13%2Felaticsearch%2F</url>
    <content type="text"><![CDATA[一、数据量比较大，上十亿百亿时，系统架构针对数据存储面临问题： 数据库选型 单点故障问题 数据安全性问题 检索难题 统计、分析数据问题 二、关系型数据库解决方案 通过主从备份解决数据安全性问题； 通过数据库代理中间件心跳监测，解决单点故障问题； 通过代理中间件将查询语句分发到各个slave节点进行查询，并汇总结果 三、非关系型数据库解决方案 通过副本备份保证数据安全性； 通过节点竞选机制解决单点问题； 先从配置库检索分片信息，然后将请求分发到各个节点，最后由路由节点合并汇总结果 ps:将数据全部放于内存中，PB级别数据分配到单台机器，满内存使用情况下，节点数太大，再考虑数据备份，节点数更大，不现实。 四、Elasticsearch在传统数据库存储的数据安全性问题，大流量下，为解决上述关系和非关系型数据库的问题，引出ES。 解决方式： 存储数据时按有序存储； 将数据和索引分离； 压缩数据； 五、ES基础 定义： 是一个开源的高扩展的分布式全文检索引擎 近乎实时的存储、检索数据； ​ 2. 扩展性好，可以扩展服务器，处理PB级别的数据；]]></content>
  </entry>
  <entry>
    <title><![CDATA[git push RPC401 curl22 error]]></title>
    <url>%2F2019%2F12%2F19%2Fgit-push-RPC401-curl22-error%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>-git RPC 401</category>
      </categories>
      <tags>
        <tag>-git push erroe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FastJson字符串转换Map的六种方法]]></title>
    <url>%2F2019%2F11%2F19%2FFastJson%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2Map%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import java.util.Map; /** JSON字符串自动转换 /public class JsonToMapTest01 { public static void main(String[] args){ String str = &quot;&#123;\&quot;0\&quot;:\&quot;zhangsan\&quot;,\&quot;1\&quot;:\&quot;lisi\&quot;,\&quot;2\&quot;:\&quot;wangwu\&quot;,\&quot;3\&quot;:\&quot;maliu\&quot;&#125;&quot;; //第一种方式 Map maps = (Map)JSON.parse(str); System.out.println(&quot;这个是用JSON类来解析JSON字符串!!!&quot;); for (Object map : maps.entrySet())&#123; System.out.println(((Map.Entry)map).getKey()+&quot; &quot; + ((Map.Entry)map).getValue()); &#125; //第二种方式 Map mapTypes = JSON.parseObject(str); System.out.println(&quot;这个是用JSON类的parseObject来解析JSON字符串!!!&quot;); for (Object obj : mapTypes.keySet())&#123; System.out.println(&quot;key为：&quot;+obj+&quot;值为：&quot;+mapTypes.get(obj)); &#125; //第三种方式 Map mapType = JSON.parseObject(str,Map.class); System.out.println(&quot;这个是用JSON类,指定解析类型，来解析JSON字符串!!!&quot;); for (Object obj : mapType.keySet())&#123; System.out.println(&quot;key为：&quot;+obj+&quot;值为：&quot;+mapType.get(obj)); &#125; //第四种方式 /** * JSONObject是Map接口的一个实现类 */ Map json = (Map) JSONObject.parse(str); System.out.println(&quot;这个是用JSONObject类的parse方法来解析JSON字符串!!!&quot;); for (Object map : json.entrySet())&#123; System.out.println(((Map.Entry)map).getKey()+&quot; &quot;+((Map.Entry)map).getValue()); &#125; //第五种方式 /** * JSONObject是Map接口的一个实现类 */ JSONObject jsonObject = JSONObject.parseObject(str); System.out.println(&quot;这个是用JSONObject的parseObject方法来解析JSON字符串!!!&quot;); for (Object map : json.entrySet())&#123; System.out.println(((Map.Entry)map).getKey()+&quot; &quot;+((Map.Entry)map).getValue()); &#125; //第六种方式 /** * JSONObject是Map接口的一个实现类 */ Map mapObj = JSONObject.parseObject(str,Map.class); System.out.println(&quot;这个是用JSONObject的parseObject方法并执行返回类型来解析JSON字符串!!!&quot;); for (Object map: json.entrySet())&#123; System.out.println(((Map.Entry)map).getKey()+&quot; &quot;+((Map.Entry)map).getValue()); &#125; String strArr = &quot;&#123;&#123;\"0\":\"zhangsan\",\"1\":\"lisi\",\"2\":\"wangwu\",\"3\":\"maliu\"&#125;," + "&#123;\"00\":\"zhangsan\",\"11\":\"lisi\",\"22\":\"wangwu\",\"33\":\"maliu\"&#125;&#125;&quot;; // JSONArray.parse() System.out.println(json); &#125; &#125; ``` ```]]></content>
      <categories>
        <category>-fastjson -map</category>
      </categories>
      <tags>
        <tag>-fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口文档书写模板]]></title>
    <url>%2F2019%2F11%2F01%2F%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E4%B9%A6%E5%86%99%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[用户调查模块信息查询请求地址userSurvey/getMessage?memberID=&#123;me&#125; 请求方法post 请求参数 名称 类型 必填 说明 memberId string true 用户ID 请求内容示例无 返回参数 名称 类型 说明 code string 状态码 message string 返回说明 orderCode string 序号 questionNaire string 调查表名称 sTime string 有效期起 endTime string 有效期止 status string 状态 返回内容示例查询成功&#123; &quot;code&quot;: &quot;0000&quot;, &quot;message&quot;: &quot;查询成功&quot;, &quot;Result&quot;: [ &#123; &quot;orderCode&quot;: &quot;1&quot;, &quot;questionNaire&quot;: &quot;2018年9月份标志业务满意度调查&quot;, &quot;sTime&quot;: &quot;2018-09-27&quot;, &quot;endTime&quot;: &quot;2018-10-15&quot;, &quot;status&quot;: &quot;0&quot; &#125;, &#123; &quot;orderCode&quot;: &quot;2&quot;, &quot;questionNaire&quot;: &quot;2018年9月份订制业务满意度调查&quot;, &quot;sTime&quot;: &quot;2018-09-27&quot;, &quot;endTime&quot;: &quot;2018-10-15&quot;, &quot;status&quot;: &quot;20&quot; &#125; ] &#125;]]></content>
      <categories>
        <category>-接口文档模板</category>
      </categories>
      <tags>
        <tag>-接口文档示例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google服务器免费VPS环境搭建]]></title>
    <url>%2F2019%2F10%2F31%2FGoogle%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%8D%E8%B4%B9VPS%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Excel Transform to PDM]]></title>
    <url>%2F2019%2F10%2F13%2FExcel-Transform-to-PDM%2F</url>
    <content type="text"><![CDATA[使用VB脚本代码，将Excel配置的表结构导入到PowerDesigner中生成对应数据库的物理表模型。 EXCEL格式表格说明：A列红色字体的数据对应PDM中表名Code,B列红色字体对应PDM中表名name 黄色框内代表每张表单的各个属性。 A列字段code、B列字段name、 C列为空时，代表这一行为声明表名的行。这里有个小问题就是，C列当为表名所在的行时必须为空；C列为字段所在行时只要不为空都可以，不需要按照表头属性填写。 其它可以看图理解。 将表名、字段名、字段数据类型、是否主键、是否为空这些必填项按照设计的表结构填写。 VB脚本VB脚本中有注释，修改对应配置好的Excel文件路径 Option Explicit Dim mdl &#39; the current model Set mdl = ActiveModel If (mdl Is Nothing) Then MsgBox &quot;There is no Active Model&quot; End If Dim HaveExcel Dim RQ RQ = vbYes &#39;MsgBox(&quot;Is Excel Installed on your machine ?&quot;, vbYesNo + vbInformation, &quot;Confirmation&quot;) If RQ = vbYes Then HaveExcel = True &#39; Open &amp; Create Excel Document Dim x1 &#39; Set x1 = CreateObject(&quot;Excel.Application&quot;) x1.Workbooks.Open &quot;C:\Users\JP\Desktop\EXCEL_PDM.xlsx&quot; &#39;指定excel文档路径 x1.Workbooks(1).Worksheets(&quot;Sheet1&quot;).Activate &#39;指定要打开的sheet名称 Else HaveExcel = False End If a x1, mdl sub a(x1, mdl) dim rwIndex dim tableName dim colname dim table dim col dim count on error Resume Next For rwIndex = 2 To 1000 &#39;指定要遍历的Excel行标 由于第1行是表头，从第2行开始 With x1.Workbooks(1).Worksheets(&quot;Sheet1&quot;) If .Cells(rwIndex, 1).Value = &quot;&quot; Then &#39;如果遍历到第一列为空，则退出 Exit For End If If .Cells(rwIndex, 3).Value = &quot;&quot; Then &#39;如果遍历到第三列为空，则此行为表名 set table = mdl.Tables.CreateNew &#39;创建表 table.Code = .Cells(rwIndex , 1).Value &#39;指定表名，第一列的值 table.Name = .Cells(rwIndex , 2).Value table.Comment = .Cells(rwIndex , 8).Value &#39;指定表注释，第二列的值 count = count + 1 Else set col = table.Columns.CreateNew &#39;创建一列/字段 &#39;MsgBox .Cells(rwIndex, 1).Value, vbOK + vbInformation, &quot;列&quot; col.Code = .Cells(rwIndex, 1).Value &#39;指定列名 &#39;MsgBox col.Name, vbOK + vbInformation, &quot;列&quot; col.Name = .Cells(rwIndex, 2).Value &#39;指定列名 col.DataType = .Cells(rwIndex, 5).Value &#39;指定列数据类型 &#39;MsgBox col.DataType, vbOK + vbInformation, &quot;列类型&quot; col.Comment = .Cells(rwIndex, 8).Value &#39;指定列说明 col.Precision = .Cells(rwIndex, 6).Value &#39;精度 If .Cells(rwIndex,9).Value=&quot;是&quot; then col.Mandatory= true &#39;是否为空 End If If .Cells(rwIndex,7).Value=&quot;Y&quot; Then col.Primary = true &#39;是否主键 End If End If End With Next MsgBox &quot;生成数据表结构共计 &quot; + CStr(count), vbOK + vbInformation, &quot;表&quot; Exit Sub End sub 脚本导入 File→New Model→PhysicalDataModel→ok 在powerDesigner中新建物理模型，并选择相应的数据库类型 2.导入脚本 tools→Execute Commands→Edit/Run Script→Run 导入对应的VB脚本，修改文件路径 3.执行结果，查看表结构 4.操作表，建立表关联关系。 PDM转Excelvb脚本Option Explicit Dim rowsNum rowsNum = 0 &#39;----------------------------------------------------------------------------- &#39; Main function &#39;----------------------------------------------------------------------------- &#39; Get the current active model Dim Model Set Model = ActiveModel If (Model Is Nothing) Or (Not Model.IsKindOf(PdPDM.cls_Model)) Then MsgBox &quot;The current model is not an PDM model.&quot; Else &#39; Get the tables collection &#39;创建EXCEL APP dim beginrow DIM EXCEL, SHEET, SHEETLIST set EXCEL = CREATEOBJECT(&quot;Excel.Application&quot;) EXCEL.workbooks.add(-4167)&#39;添加工作表 EXCEL.workbooks(1).sheets(1).name =&quot;表结构&quot; set SHEET = EXCEL.workbooks(1).sheets(&quot;表结构&quot;) EXCEL.workbooks(1).sheets.add EXCEL.workbooks(1).sheets(1).name =&quot;目录&quot; set SHEETLIST = EXCEL.workbooks(1).sheets(&quot;目录&quot;) ShowTableList Model,SHEETLIST ShowProperties Model, SHEET,SHEETLIST EXCEL.workbooks(1).Sheets(2).Select EXCEL.visible = true &#39;设置列宽和自动换行 sheet.Columns(1).ColumnWidth = 20 sheet.Columns(2).ColumnWidth = 20 sheet.Columns(3).ColumnWidth = 20 sheet.Columns(4).ColumnWidth = 40 sheet.Columns(5).ColumnWidth = 10 sheet.Columns(6).ColumnWidth = 10 sheet.Columns(1).WrapText =true sheet.Columns(2).WrapText =true sheet.Columns(4).WrapText =true &#39;不显示网格线 EXCEL.ActiveWindow.DisplayGridlines = False End If &#39;----------------------------------------------------------------------------- &#39; Show properties of tables &#39;----------------------------------------------------------------------------- Sub ShowProperties(mdl, sheet,SheetList) &#39; Show tables of the current model/package rowsNum=0 beginrow = rowsNum+1 Dim rowIndex rowIndex=3 &#39; For each table output &quot;begin&quot; Dim tab For Each tab In mdl.tables ShowTable tab,sheet,rowIndex,sheetList rowIndex = rowIndex +1 Next if mdl.tables.count &gt; 0 then sheet.Range(&quot;A&quot; &amp; beginrow + 1 &amp; &quot;:A&quot; &amp; rowsNum).Rows.Group end if output &quot;end&quot; End Sub &#39;----------------------------------------------------------------------------- &#39; Show table properties &#39;----------------------------------------------------------------------------- Sub ShowTable(tab, sheet,rowIndex,sheetList) If IsObject(tab) Then Dim rangFlag rowsNum = rowsNum + 1 &#39; Show properties Output &quot;================================&quot; sheet.cells(rowsNum, 1) =tab.name sheet.cells(rowsNum, 1).HorizontalAlignment=3 sheet.cells(rowsNum, 2) = tab.code &#39;sheet.cells(rowsNum, 5).HorizontalAlignment=3 &#39;sheet.cells(rowsNum, 6) = &quot;&quot; &#39;sheet.cells(rowsNum, 7) = &quot;表说明&quot; sheet.cells(rowsNum, 3) = tab.comment &#39;sheet.cells(rowsNum, 8).HorizontalAlignment=3 sheet.Range(sheet.cells(rowsNum, 3),sheet.cells(rowsNum, 7)).Merge &#39;设置超链接，从目录点击表名去查看表结构 &#39;字段中文名 字段英文名 字段类型 注释 是否主键 是否非空 默认值 sheetList.Hyperlinks.Add sheetList.cells(rowIndex,2), &quot;&quot;,&quot;表结构&quot;&amp;&quot;!B&quot;&amp;rowsNum rowsNum = rowsNum + 1 sheet.cells(rowsNum, 1) = &quot;字段中文名&quot; sheet.cells(rowsNum, 2) = &quot;字段英文名&quot; sheet.cells(rowsNum, 3) = &quot;字段类型&quot; sheet.cells(rowsNum, 4) = &quot;注释&quot; sheet.cells(rowsNum, 5) = &quot;是否主键&quot; sheet.cells(rowsNum, 6) = &quot;是否非空&quot; sheet.cells(rowsNum, 7) = &quot;默认值&quot; &#39;设置边框 sheet.Range(sheet.cells(rowsNum-1, 1),sheet.cells(rowsNum, 7)).Borders.LineStyle = &quot;1&quot; &#39;sheet.Range(sheet.cells(rowsNum-1, 4),sheet.cells(rowsNum, 9)).Borders.LineStyle = &quot;1&quot; &#39;字体为10号 sheet.Range(sheet.cells(rowsNum-1, 1),sheet.cells(rowsNum, 7)).Font.Size=10 Dim col &#39; running column Dim colsNum colsNum = 0 for each col in tab.columns rowsNum = rowsNum + 1 colsNum = colsNum + 1 sheet.cells(rowsNum, 1) = col.name &#39;sheet.cells(rowsNum, 3) = &quot;&quot; &#39;sheet.cells(rowsNum, 4) = col.name sheet.cells(rowsNum, 2) = col.code sheet.cells(rowsNum, 3) = col.datatype sheet.cells(rowsNum, 4) = col.comment If col.Primary = true Then sheet.cells(rowsNum, 5) = &quot;Y&quot; Else sheet.cells(rowsNum, 5) = &quot; &quot; End If If col.Mandatory = true Then sheet.cells(rowsNum, 6) = &quot;Y&quot; Else sheet.cells(rowsNum, 6) = &quot; &quot; End If sheet.cells(rowsNum, 7) = col.defaultvalue next sheet.Range(sheet.cells(rowsNum-colsNum+1,1),sheet.cells(rowsNum,7)).Borders.LineStyle = &quot;3&quot; &#39;sheet.Range(sheet.cells(rowsNum-colsNum+1,4),sheet.cells(rowsNum,9)).Borders.LineStyle = &quot;3&quot; sheet.Range(sheet.cells(rowsNum-colsNum+1,1),sheet.cells(rowsNum,7)).Font.Size = 10 rowsNum = rowsNum + 2 Output &quot;FullDescription: &quot; + tab.Name End If End Sub &#39;----------------------------------------------------------------------------- &#39; Show List Of Table &#39;----------------------------------------------------------------------------- Sub ShowTableList(mdl, SheetList) &#39; Show tables of the current model/package Dim rowsNo rowsNo=1 &#39; For each table output &quot;begin&quot; SheetList.cells(rowsNo, 1) = &quot;主题&quot; SheetList.cells(rowsNo, 2) = &quot;表中文名&quot; SheetList.cells(rowsNo, 3) = &quot;表英文名&quot; SheetList.cells(rowsNo, 4) = &quot;表说明&quot; rowsNo = rowsNo + 1 SheetList.cells(rowsNo, 1) = mdl.name Dim tab For Each tab In mdl.tables If IsObject(tab) Then rowsNo = rowsNo + 1 SheetList.cells(rowsNo, 1) = &quot;&quot; SheetList.cells(rowsNo, 2) = tab.name SheetList.cells(rowsNo, 3) = tab.code SheetList.cells(rowsNo, 4) = tab.comment End If Next SheetList.Columns(1).ColumnWidth = 20 SheetList.Columns(2).ColumnWidth = 20 SheetList.Columns(3).ColumnWidth = 30 SheetList.Columns(4).ColumnWidth = 60 output &quot;end&quot; End Sub]]></content>
      <categories>
        <category>-PDM -VB Script</category>
      </categories>
      <tags>
        <tag>-PDM -Excel -VB Script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot学习资料]]></title>
    <url>%2F2019%2F10%2F09%2FSpringBoot%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%2F</url>
    <content type="text"><![CDATA[该文主要作为学习SpringBoot时看到的资料链接整理。文中内容都是原博主原创文章和官网链接。感谢前人种树，让自己学有所得。 ImportNew公众号的SpringBoot教程系列 SpringBoot (一) ：入门篇 http://mp.weixin.qq.com/s/hAJmvrYfS6OehMYVgqpqkw SpringBoot ( 二 ) ：web 综合开发http://mp.weixin.qq.com/s/7jBT-vS7yD4daCzGWFX1OQ SpringBoot (三) ：Spring Boot 中 Redis 的使用http://mp.weixin.qq.com/s/05sAOza-B7jlWrllj1lZ0Q SpringBoot ( 四 ) ：thymeleaf 使用详解http://mp.weixin.qq.com/s/d1nLZuzaZ9MDj2rV-52oIw SpringBoot ( 五) ：spring data jpa 的使用http://mp.weixin.qq.com/s/fAcOvQutfWosyh10wAjmSA SpringBoot (六) ：如何优雅的使用 mybatishttps://mp.weixin.qq.com/s/oDbcHyjyS4gc5wS85PbfLA SpringBoot ( 七 ) ：springboot + mybatis 多数据源最简解决方案http://mp.weixin.qq.com/s/TXGiYzqi2oCXuN4xuPy5Zw SpringBoot ( 八 ) ：RabbitMQ 详解http://mp.weixin.qq.com/s/5G3wHzNzpcUlBLwqOJ7BUQ SpringBoot ( 九 ) ：定时任务http://mp.weixin.qq.com/s/8JRuyh6FMZCobQVkk-isQA SpringBoot ( 十 ) ：邮件服务 http://mp.weixin.qq.com/s/Rbb9CyMNjhzIHSo4gqQopQ SpringBoot ( 十一 ) ：SpringBoot 中 mongodb 的使用http://mp.weixin.qq.com/s/T-u8ste30Ks4fezd0g3tOw SpringBoot ( 十二 ) ：SpringBoot 如何测试打包部署http://mp.weixin.qq.com/s/WJ6WIirmj4CCuwaHb8YTjg SpringBoot ( 十三 ) ：SpringBoot 小技巧http://mp.weixin.qq.com/s/-Amwc9BZBGATcpCOfpPD8g SpringBoot (十四 ) ：SpringBoot 整合 shiro- 登录认证和权限管理http://mp.weixin.qq.com/s/344c8r-mjtabSo5QQ1MY-A SpringBoot系列基础教程 版权声明：本文为CSDN博主「MinboHe」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/hemin1003/article/details/82038244 Spring Boot系列 - 1. 简介https://blog.csdn.net/hemin1003/article/details/53217308 Spring Boot系列 - 2. Spring Boot提供的特性https://blog.csdn.net/hemin1003/article/details/53217388 Spring Boot系列 - 3. SpringBoot项目学习汇总https://blog.csdn.net/hemin1003/article/details/53217489 Spring Boot系列 - 4. 读取配置文件（application.yml）中的属性值https://blog.csdn.net/hemin1003/article/details/53227523 Spring Boot系列 - 5. 不同的环境使用不同的配置https://blog.csdn.net/hemin1003/article/details/53229053 Spring Boot系列 - 6. spring boot 实现Restful APIhttps://blog.csdn.net/hemin1003/article/details/53229083 Spring Boot系列 - 7. Spring Boot 部署与服务配置https://blog.csdn.net/hemin1003/article/details/75644985 为什么说 Java 程序员必须掌握 Spring Boot ？https://kb.cnblogs.com/page/606682/ SpringBoot实现分布式锁http://www.itmuch.com/spring-boot/global-lock/ SpringBoot进阶系列–基于springboot 2.0.6.RELEASE 版权声明：本文为CSDN博主「MinboHe」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/hemin1003/article/details/82038244 SpringBoot从入门到精通教程（一） 如何进行单元测试编写和场景案例分析https://blog.csdn.net/hemin1003/article/details/90214986 SpringBoot从入门到精通教程（二） 拦截器用法和场景案例分析https://blog.csdn.net/hemin1003/article/details/90242803 SpringBoot从入门到精通教程（三） RocketMQ集成和场景案例分析https://blog.csdn.net/hemin1003/article/details/90405506 SpringBoot从入门到精通教程（四） @Scheduled定时器用法和场景案例分析https://blog.csdn.net/hemin1003/article/details/90454462 SpringBoot从入门到精通教程（五） 内嵌Tomcat自定义配置用法https://blog.csdn.net/hemin1003/article/details/91991433 SpringBoot从入门到精通教程（六） Mysql和Mybatis+XML用法详解https://blog.csdn.net/hemin1003/article/details/93123524 SpringBoot从入门到精通教程（七） Mysql多数据源和Hikari用法详解https://blog.csdn.net/hemin1003/article/details/94194400 SpringBoot从入门到精通教程（八） 多环境配置文件用法https://blog.csdn.net/hemin1003/article/details/96483484 SpringBoot从入门到精通教程（九） Docker集成+容器化部署详解/上篇https://blog.csdn.net/hemin1003/article/details/96483517 SpringBoot从入门到精通教程（十） Docker集成+容器化部署详解/下篇使用Dockerfile进行构建https://hemin.blog.csdn.net/article/details/99676483 SpringBoot从入门到精通教程（十一） 分布式缓存Redis整合/解决中文乱码问题https://blog.csdn.net/hemin1003/article/details/96483538 SpringBoot从入门到精通教程（十二） Dubbo服务提供者、服务消费者整合/Zookeeper集成https://blog.csdn.net/hemin1003/article/details/96483573 SpringBoot从入门到精通教程（十三） 全局唯一ID/分布式ID解决方案https://blog.csdn.net/hemin1003/article/details/96483588 SpringBoot从入门到精通教程（十四） Druid连接池集成https://blog.csdn.net/hemin1003/article/details/99637453 SpringBoot从入门到精通教程（十五） Logback日志框架集成https://blog.csdn.net/hemin1003/article/details/99637532 SpringBoot从入门到精通教程（十六） ELK日志集成https://blog.csdn.net/hemin1003/article/details/99637553 SpringBoot从入门到精通教程（十七） 日志异步化处理用法https://blog.csdn.net/hemin1003/article/details/99637609 SpringBoot从入门到精通教程（十八） 全局异常处理https://blog.csdn.net/hemin1003/article/details/99637714 SpringBoot从入门到精通教程（十九） API接口防刷机制https://blog.csdn.net/hemin1003/article/details/99637749 SpringBoot从入门到精通教程（二十） 分布式锁用法（基于Redis实现）https://blog.csdn.net/hemin1003/article/details/99637778 SpringBoot从入门到精通教程（二十一） MongoDB集成用法https://hemin.blog.csdn.net/article/details/99637830 SpringBoot从入门到精通教程（二十二） Oauth2+Token详细用法/SpringSecurityhttps://blog.csdn.net/hemin1003/article/details/96483440 Server端对应的Github源码地址https://github.com/hemin1003/spring-boot-study/tree/master/spring-boot2-study/spring-boot2-parent/spring-boot2-oauth2-opaque-server SpringBoot从入门到精通教程（二十三） Oauth2+JWT集成/SpringSecurityhttps://hemin.blog.csdn.net/article/details/96483461 Server端对应的Github源码地址https://github.com/hemin1003/spring-boot-study/tree/master/spring-boot2-study/spring-boot2-parent/spring-boot2-oauth2-jwt-server SpringBoot从入门到精通教程（二十四） Swagger集成用法https://hemin.blog.csdn.net/article/details/99637936]]></content>
      <categories>
        <category>-SpringBoot -学习资料</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot二：Externalized Configuration外部化配置]]></title>
    <url>%2F2019%2F10%2F04%2FSpringBoot%E4%BA%8C%EF%BC%9AExternalized-Configuration%E5%A4%96%E9%83%A8%E5%8C%96%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[SpringBoot外部化配置官方配置介绍文档 官方配置文档 外部化配置参数方式SrpingBoot除了帮我们完成一些自动配置的同时，也允许我们使用外部化配置覆盖原有配置。以便于在不同的环境中使用相同的应用程序代码。 外部化配置的方式可以是下列几种： ​ ——–properties文件 ​ ——–YAML文件 ​ ——–环境变量 ​ ——–命令行参数 属性值可以通过@Value直接注入，通过访问Spring的Environment抽象或者通过结构化对象@ConfigurationProperties绑定。在与@ConfigurationProperties映射时，prefix=“param”,param不能以大写字母开头，必须是小写,有分隔符必须是连字符-，比如my-name，my_name不行。否则项目启动时报错： Description: Configuration property name &#39;Student2&#39; is not valid: Invalid characters: &#39;S&#39; Bean: /stu2 Reason: Canonical names should be kebab-case (&#39;-&#39; separated), lowercase alpha-numeric characters and must start with a letter Action: Modify &#39;Student2&#39; so that it conforms to the canonical names requirements. ​ SpringBoot Configration Processor not found int classpath //错误信息 ​ 原因:spring配置注解未在classpath中未找到，springboot1.5以上@ConfigurationProperties取消位置注解 ​ 解决方案：在Entity实体上加注解@PropertySource(“application.properties”) 配置随机数随机数属性源（RandomValuePropertySource）可用于注入随机数。它可以生成int,long,uuid,String等数据类型的随机数，例如 my.secret=$&#123;random.vaue&#125; my.number=$&#123;random.int&#125; my.uuid=$&#123;random.uuid&#125; my.bignumber=$&#123;random.long&#125; my.number.less.than-ten=$&#123;random.int(10)&#125; #某个范围内的值 my.number.in-range=$&#123;random.int[15,999]&#125; YAML配置和properties配置 properties配置就是普通的键值对 key=value 形式。 例： website.github=www.github.com YAML配置：YAML是JSON的超集，是一种用于指定层次结构配置数据的便捷格式。只要在类路径上具有SnakeYAML库，SpringApplication类就会自动支持YAML作为属性的替代方法。 yaml文件相关说明​ spring提供两个对应的工厂类，可用于加载YAML文件。YamlPropertiesFactoryBean 加载属性作为properties键值对，YamlMapFactoryBean 加载属性作为Map对象。 例如配置文件application.yaml environment： #生产环境 prod: url: http://dumboj.top name: myblog #开发环境 dev: url: http://dumboj.github.io name: myblogDev ##!!!YAML的相同缩进代表同级，带属性值的key：value,:后必须有空格 示例将被转换成以下属性： environment.prod.url=http://dumboj.top environment.prod.name=myblog environment.dev.url=http://dumboj.github.io environment.dev.name=myblogDev YAML文件可以用[index]表示属性值。例如： server: url: -localhost: 8080 -localhost: 8081 可以转化成： server.url[0]=localhost:8080 server.url[1]=localhost:8081 @ConfigurationProperties 绑定属性提供对应属性的setter方法，上面例子就可以表示为： @ConfigurationProperties(prefix=&quot;server&quot;) public class config()&#123; private List&lt;String&gt; url = new ArrayList&lt;String&gt;(); public List&lt;String&gt; getUrl() &#123; return this.Url; &#125; &#125;]]></content>
      <categories>
        <category>-springboot</category>
      </categories>
      <tags>
        <tag>-springboot -微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse和IDEA中.ignore过滤文件]]></title>
    <url>%2F2019%2F10%2F02%2Feclipse%E5%92%8CIDEA%E4%B8%AD-ignore%E8%BF%87%E6%BB%A4%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[.class .mtj.tmp/ *.jar *.war *.ear hs_err_pid* target .classpath .project .settings .gitignore bin .apt_generated_tests .apt_generated .factorypath logs .springBeans .idea *.iml out gen]]></content>
      <categories>
        <category>-eclipse -IDEA -ignore</category>
      </categories>
      <tags>
        <tag>-.ignore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java spi]]></title>
    <url>%2F2019%2F09%2F25%2Fjava-spi%2F</url>
    <content type="text"><![CDATA[Java SPI简介java SPI ：java Service Provider Interface ​ 是java中的一个服务加载方式。根据Java SPI规范，可以定义一个接口，具体实现由服务提供者去具体实现。在使用时可以通过SPI的规范获取对应实现类。通过SPI服务加载机制可以实现服务的注册和调用，有效避免代码耦合，基于接口编程，实现模块间的解耦。 SPI应用场景 JDBC中数据的驱动加载 dubbo框架中也用到SPI原理，dubbo对JAVA SPI进行封装，可以通过过滤器加载部分实现类 SPI规范 在项目main/resource/META-INF/services下创建以接口全路径名为包名的文件，文件内容为具体需要加载实现类的全包名路径 使用ServiceLoader动态加载实现类：具体为ServiceLoader加载接口字节码对象，通过对ServiceLoader对象Iterator迭代获取所有实现类 SPI实现打成jar包，需要放在classpath中 实现类必须有无参构造。（有带参构造时需显式声明） SPI简单案例​ github—–spitest ​ 创建一个Maven工程 ​ 目录结构： ​ ​ 接口类：src/main/java/package_name/People /**SPI接口*/ public interface People &#123; public String skin();//肤色 &#125; 具体实现类： Chinese /**SPI实现类一*/ public class Chinese implements People &#123; public String skin() &#123; return &quot;Chinese is yellow skin&quot;;//黄皮肤 &#125; &#125; American /**SPI实现类二*/ public class American implements People &#123; public String skin() &#123; return &quot;American is white skin&quot;;//白皮肤 &#125; &#125; 在src/main/resources下创建目录META-INF，并以接口全路径为名创建文件，文件内容为实现类的全路径名 cn.dumboj.test.spi.American cn.dumboj.test.spi.Chinese 测试： /**SPI测试类*/ public class TestSpi &#123; public static void main(String[] args) &#123; ServiceLoader&lt;People&gt; loader = ServiceLoader.load(People.class); Iterator&lt;People&gt; skins = loader.iterator(); //实现类迭代器 while(skins.hasNext())&#123; //实现类遍历 System.out.println(skins.next().skin()); &#125; &#125; &#125; 测试结果： American is white skin Chinese is yellow skin 总结从案例可以看出，在我们有更多具体实现需求时，只需要创建工程并基于对应接口实现，并在META-INF/services下做相应文件配置，将工程打包，就完成新服务的开发。]]></content>
      <categories>
        <category>-java spi -java 基础</category>
      </categories>
      <tags>
        <tag>-java基础 -java spi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[githubDNS问题]]></title>
    <url>%2F2019%2F09%2F21%2FgithubDNS%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[github.com访问缓慢 打开C:\Windows\System32\drivers\etc路径下hosts文件 添加 192.30.253.112 github.com 192.30.253.119 gist.github.com 151.101.100.133 assets-cdn.github.com 151.101.100.133 raw.githubusercontent.com 151.101.100.133 gist.githubusercontent.com 151.101.100.133 cloud.githubusercontent.com 151.101.100.133 camo.githubusercontent.com 151.101.100.133 avatars0.githubusercontent.com 151.101.100.133 avatars1.githubusercontent.com 151.101.100.133 avatars2.githubusercontent.com 151.101.100.133 avatars3.githubusercontent.com 151.101.100.133 avatars4.githubusercontent.com 151.101.100.133 avatars5.githubusercontent.com 151.101.100.133 avatars6.githubusercontent.com 151.101.100.133 avatars7.githubusercontent.com 151.101.100.133 avatars8.githubusercontent.com cmd ： ipconfig/flushdns 秒连………. 老人，手机，地铁？？？ 修改后几日发现上传文件时，在markdown文件中添加图片路径需要访问该图片地址，访问时一直被浏览器拦截，github全站图片信息都不加载。将上述配置注释，刷新DNS设置，访问正常。 ++++++++++NDS相关知识]]></content>
      <categories>
        <category>-githubDNS设置</category>
      </categories>
      <tags>
        <tag>-小疑问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot入门案例]]></title>
    <url>%2F2019%2F09%2F19%2Fspringboot%E5%85%A5%E9%97%A8%E4%B8%80%2F</url>
    <content type="text"><![CDATA[maven:简化jar包的依赖关系 springboot：简化项目架构构建 Hello World 讲解项目构建-pom.xml配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- srpingboot 父模块 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.8.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- web依赖，包含springMVC引用 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 作为一个可执行jar --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; springBoot启动类 ​ 利用IDEA或者Eclipse构建一个基础SpringBoot项目后，在src/main/java下会生成一个启动类文件xxxApplication @SpringBootApplication public class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125; &#125; @SpringBootApplication注解Spring Boot应用标识 SpringApplication对象main函数作为应用入口，SpringAppliction引导类，run方法加载应用本身字节码文件，通过嵌入的Tomcat加载项目。 快速入门案例@RestController class ThisWillActuallyRun &#123; @RequestMapping(&quot;/&quot;) String home() &#123; &quot;Hello World!&quot; &#125; &#125; @RestController和@RequestMapping是SpringMVC的注解 @RestController标注一个Controller，返回格式为Json数据，xml或标准字符串 另一个标识C层接口的注解@Controller，返回Json格式数据时需要在具体方法返回时加@ResponseBody注解 @RequestMapping提供路由信息，前端请求会根据注解后的路径把前端请求映射到对应方法中处理。 简单修改默认配置信息springboot维护很多默认配置信息，可以通过src/main/resources/application.properties或者application*.yml/application*.yaml修改。 #修改嵌入Tomcat端口号 #服务器端口 server.port=8081 springboot的配置清单可移步官方配置清单查看 https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html 发布访问启动springboot入口类的main方法 localhost:8081/访问页面，页面返回 first springboot 小结： 入门项目搭建，pom.xml配置 启动类及注解详解 项目访问]]></content>
      <categories>
        <category>-springboot</category>
      </categories>
      <tags>
        <tag>-springboot -微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue frame]]></title>
    <url>%2F2019%2F09%2F15%2Fvue-frame%2F</url>
    <content type="text"><![CDATA[vue学习 消息显示 绑定事件 悬停显示 条件判定app3.seen = false不可见 now you can seen me 循环app4.todos.push({text:"something"})添加元素 事件 Reverse v-model指令，实现表单输入和应用状态之间的双向绑定 var app = new Vue({ el:"#app", data:{ message:"Hello Vue!ss...." } }); var app2 = new Vue({ el:"#app2", data:{ message2:"hold on ,I will stay~~信息查看于"+new Date().toLocaleString() } }); var app3 = new Vue({ el:"#app3", data:{ seen:"true" } }); var app4 = new Vue({ el:"#app4", data:{ todos : [ {text:"study js"}, {text:"study vue"}, {text:"do something cool"} ] } }); var app5 = new Vue({ el:"#app5", data:{ message3:"I wants reverse!" }, methods:{ reverseMessage:function(){ this.message3 = this.message3.split('').reverse().join(''); } } }); var app6 = new Vue({ el:"#app6", data:{ message6:"Restful API" } });]]></content>
      <categories>
        <category>-vue官网文档小试</category>
      </categories>
      <tags>
        <tag>-vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构和算法之美]]></title>
    <url>%2F2019%2F09%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%2F</url>
    <content type="text"><![CDATA[时间复杂度：代码执行时间随数据规模增长的变化趋势，也称渐进时间复杂度。空间复杂度：……………………..存储空间………………………………….空间………….原则： ​ 只关注循环执行最多的一段代码 加法法则：总复杂度等于量级最大的那段代码的复杂度 乘法法则：嵌套代码的复杂度等于嵌套内外代码度的乘积 $$T(n) = O(f(n)) 所有代码的执行时间T(n)与每行代码的执行次数n成正比$$ $$T(n):代码执行时间$$ $$f(n)每行代码执行的总和$$ 复杂度量级：$$常量阶 O(1)$$ $$指数阶O(2)$$ $$对数阶O(logn)$$ $$阶乘阶0(n!)$$ $$线性阶O(n)$$ $$线性对数阶O(nlogn)归并排序、快速排序的时间复杂度$$ $$平方阶O(n²)$$ $$立方阶O(n³)$$ 常见复杂度排序：$$O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n²)$$]]></content>
      <categories>
        <category>-数据结构与算法</category>
      </categories>
      <tags>
        <tag>-数据结构 -算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx_高性能WEB服务器]]></title>
    <url>%2F2019%2F08%2F17%2FNginx-%E9%AB%98%E6%80%A7%E8%83%BDWEB%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Nginx 高性能web服务器基础1.Nginx介绍2.Nginx安装启动安装包下载以Linux版本为例：​ 1.ssh登录阿里云CentOS7服务器 ​ 2.下载安装包 wget http://nginx.org/download/nginx-1.16.1.tar.gz ​ 3.解压文件 tar -zxvf nginx-1.16.1.tar.gz ​ 4.进入文件目录，编译安装 ./configure --prefix=/usr/local/projinstall/nginx ​ 我安装时遇到的情景： ./configure: error: the HTTP gzip module requires the zlib library. You can either disable the module by using --without-http_gzip_module option, or install the zlib library into the system, or build the zlib library statically from the source with nginx by using --with-zlib=&lt;path&gt; option. 系统中缺少zlib库 解决-- yum install -y zlib yum install -y zlib-devel error while loading shared libraries: libpcre.so.0: cannot open shared object file: No such file or directory 系统中缺少pcre库 解决-- yum install -y pcre yum install -y pcre-devel 编译无错误信息后安装 make &amp;&amp; make install 5.启动Nginx cd /usr/local/projinstall/nginx 目录 说明 conf 配置文件 html 网页文件 logs 日志文件 sbin 只要二进制程序 cd ./sbin ls ./nginx 启动成功 ​ 注：若有端口占用情况，启动nginx服务器失败 netstat -ant|p --查看占用端口情况 pkill -9 pid --解除端口占用 ./nginx --再次启动服务 Nginx信号控制 信号参数 说明 TERM, INT Quick shutdown QUIT Graceful shutdown KILL Halts a stubborn process HUP Configuration reload –重新加载重读配置文件、 Start the new worker processes with a new configuration、 Gracefully shutdown the old worker processes USR1 Reopen the log files–日志切割：kill -USER1 pid ，（重命名日志文件，再新建原名日志） USR2 Upgrade Executable on the fly 平滑的升级，当旧进程请求完毕则关闭 WINCH Gracefully shutdown the worker processes Nginx命令控制： 命令 说明 ./sbin/nginx -s reload 配合文件修改重启加载 ./sbin/nginx -s stop 结束进程 ./sbin/nginx 启动nginx ./sbin/nginx -t 确认修改的配置文件是否正确 ./sbin/nginx -s reopen 重新写入新的日志文件 ​ 应用部分1.Nginx虚拟主机配置user www www; ## Default: nobody worker_processes 5; ## Default: 1 工作子进程。一般为CPU*核心数，太大争夺CPU error_log logs/error.log; pid logs/nginx.pid; worker_rlimit_nofile 8192; events &#123; #evert区，配置nginx连接的特性，一个work同时允许多少个连接 worker_connections 4096; ## Default: 1024 子进程最大允许连4096个连接 &#125; #配置http服务器 http &#123; include conf/mime.types; include /etc/nginx/proxy.conf; include /etc/nginx/fastcgi.conf; index index.html index.htm index.php; default_type application/octet-stream; log_format main &#39;$remote_addr - $remote_user [$time_local] $status &#39; &#39;&quot;$request&quot; $body_bytes_sent &quot;$http_referer&quot; &#39; &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;; access_log logs/access.log main; sendfile on; tcp_nopush on; server_names_hash_bucket_size 128; # this seems to be required for some vhosts server &#123; # php/fastcgi listen 80; server_name domain1.com www.domain1.com; access_log logs/domain1.access.log main; root html; location ~ \.php$ &#123; fastcgi_pass 127.0.0.1:1025; &#125; &#125; server &#123; # simple reverse-proxy listen 80; server_name domain2.com www.domain2.com; access_log logs/domain2.access.log main; # serve static files location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123; root /var/www/virtual/big.server.com/htdocs; expires 30d; &#125; # pass requests for dynamic content to rails/turbogears/zope, et al location / &#123; proxy_pass http://127.0.0.1:8080; &#125; server&#123; listen 80; server_name dumboj.cn &#125; &#125; upstream big_server_com &#123; server 127.0.0.3:8000 weight=5; server 127.0.0.3:8001 weight=5; server 192.168.0.1:8000; server 192.168.0.1:8001; &#125; server &#123; # simple load balancing listen 80; server_name big.server.com; access_log logs/big.server.access.log main; location / &#123; proxy_pass http://big_server_com; &#125; &#125; &#125; 2.Nginx日志切割​ Nginx的配置文件中，server{access_log logs/domain2.access.log main;} ​ Nginx允许每个不同的虚拟主机server写入到不同的log文件 3.Nginx与gzip设置]]></content>
      <categories>
        <category>-Nginx</category>
      </categories>
      <tags>
        <tag>-Nginx -Web服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java容器]]></title>
    <url>%2F2019%2F08%2F09%2Fjava%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[ArrayList1.概览：ArrayList基于数组实现，RandomAccess接口标识该类支持快速随机访问。public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 数组默认初始大小为10 private static final int DEFAULT_CAPACITY = 10; 2.扩容：添加元素时使用ensureCapacityInternal（）方法来保证容量足够，如果不够时，需要使用grow（）方法扩容，新容量的大小为旧容量的1.5倍。 扩容操作时需要调用Arrays.copyof()把原数组复制到新数组中，这个操作代价很高。因此最好在创建时ArrayList对象时就指定大概的容量大小，减少扩容操作的次数。 public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; 3.删除元素删除元素时需要调用System.arraycopy()将index+1后面的元素都复制到index上，该操作的时间复杂度为O(N),可以看出ArrayList删除元素的代价也很高。 public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; 4.Fail-FastmodeCount用来记录ArrayList结构发生变化的次数。结构发生变化是指ArrayList添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，设置元素的值不算结构发生变化。 在进行序列化或者迭代等操作时，需要比较前后的modeCount是否改变，改变了需要抛出ConcurrentModificationException private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; 5.序列化ArrayList基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，没必要全部进行序列化。 保存元素的数组elementData使用transient修饰，该关键字声明数组默认不会被序列化。 transient Object[] elementData; // non-private to simplify nested class access ArrayList实现了writteObject()和readObject来控制只序列化数组中有元素填充那部分内容。 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125; &#125; private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; 2.Vector它的实现与ArrayList类似，但是它使用synchronized进行同步。 public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true; &#125; public synchronized E get(int index) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); return elementData(index); &#125; 与ArrayList比较 Vector是同步的，因此开销比ArrayList更大，访问速度更慢。最好使用ArrayList而不是Vector，因为同步操作完全可以由程序员自己来控制。 Vector每次扩容请求其大小的两倍（也可以通过构造函数来设置），ArrayList是1.5倍 替代方案 使用Collections.synchroniedList();得到一个线程安全的ArrayListList&lt;String&gt; list = new ArrayList&lt;&gt;(); List&lt;String&gt; synList = Collections.synchronizedList(list); 并发包下的CopyOnWriteArrayList类List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); 读写分离：写操作在复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。 写操作需要加锁，防止并发写入时导致写入数据丢失。 写操作结束后，需要把原始数组指向新的复制数组。 public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125; &#125; final void setArray(Object[] a) &#123; array = a; &#125; @SuppressWarnings(&quot;unchecked&quot;) private E get(Object[] a, int index) &#123; return (E) a[index]; &#125; 适用场景：CopyOnWriteArrayList在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。 缺陷： 内存占用：写操作时需要复制一个新的数组，使得内存占用为原来的两倍。 数据不一致。读操作时不能读取实时性的数据，因为部分写操作还没同步到读数组中。 所以CopyOnWriteArrayList不适合内存敏感以及实时性要求很高的场景。 3.LinkedList1.概览：基于双向链表实现，使用Node存储链表节点信息。private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; &#125; 每个链表存储了first和last指针。 transient Node&lt;E&gt; first; transient Node&lt;E&gt; last; 2.与ArrayList比较 ArrayList基于动态数组实现，LinkedList基于双向链表实现 ArrayList支持随机访问，LinkedList不支持。 LinkedList在任意位置添加删除元素更快。 HashMap1.存储结构：内部包含一个Entry[]类型的数组tablejava1.7中使用 transient Entry[] table; java1.8中使用 transient Node&lt;K,V&gt;[] table; Entry和Node存储着键值对，从源码中next可以看出Entry或Node都是一个链表。数组中的每个位置都都被当成一个桶，一个桶存放一个链表。 HashMap使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的键值对对象（Entry或Node） 2.拉链法的工作原理：HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;K1&quot;, &quot;V1&quot;); map.put(&quot;K2&quot;, &quot;V2&quot;); map.put(&quot;K3&quot;, &quot;V3&quot;); 新建一个HashMap，默认的大小为16 计算k1的hashCode为115，对16取模=3；k2,k3的hashCode为118，对16取模为6， 链表的插入方式是以头插法方式进行的，对应&lt;k3,v3&gt;应在链表头部，即&lt;k2，v2&gt;前 查找分为两步进行 根据需要查找的key值确定桶所在位置 在链表上顺序查找，时间幅度和链表长度成正比 3.put操作HashMap允许键为null的键值对。因无法确定null的哈希值，采用的是强制指定桶下标来存放。HashMap使用第0个桶存放键为null的键值对。 public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; // 键为 null 单独处理 if (key == null) return putForNullKey(value); int hash = hash(key); // 确定桶下标 int i = indexFor(hash, table.length); // 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; // 插入新键值对 addEntry(hash, key, value, i); return null; &#125; //键为null的键值对put（） private V putForNullKey(V value) &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(0, null, value, 0); return null; &#125; 4.扩容设HashMap的长度为M，需要存储的键值对数量为N，如果哈希函数满足均匀性要求，则每条链表的长度为N/M。 因此，为了让查找的成本降低，应该让table也就是M尽可能大。HashMap采用动态扩容，根据N的数量来调整M的值，保证空间效率和时间效率。 扩容操作同样需要将oldTable的键值对重新插入newTable中，这一步很费时。 5.重新计算桶下标扩容时需要把键值对重新放在对应的桶上。HashMap使用了一个特殊的机制，降低重新计算桶下标的操作。 假设原数组长度为16，扩容后的new capacity为32； capacity : 00010000 new capacity : 00100000 对于一个key： 它的哈希值如果在第5位上为0，则取模和之前得到的哈希值一致 如果为1，则得到的结果为原来的结果+16 6.链表转红黑树JDK1.8后，当桶存储的链表的长度&gt;=8时，会将链表转换为红黑树。 7.HashMap和HashTable的比较 HashTable使用synchronized进行同步，即HashTable是线程安全的 HashMap允许键为null HashMap使用fail-fast迭代器 HashMap不能保证随着时间的推移Map中的元素次序是不变的（扩容重新计算哈希值） 4.ConcurrentHashMapstatic final class HashEntry&lt;K,V&gt; &#123; final int hash; final K key; volatile V value; volatile HashEntry&lt;K,V&gt; next; &#125; ConcurrentHashMap和HashMap实现上类似。区别在于ConcurrentHashMap引入了分段锁（Segement）。每个Segment维护着几个HashEntry，多个线程可以同时访问不同分段锁上的桶，并发度更高（并发量即Segment的个数） Segment继承自ReentrantLockstatic final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123; private static final long serialVersionUID = 2249069246763182397L; static final int MAX_SCAN_RETRIES = Runtime.getRuntime().availableProcessors() &gt; 1 ? 64 : 1; ​ transient volatile HashEntry&lt;K,V&gt;[] table; ​ transient int count; ​ transient int modCount; ​ transient int threshold; ​ final float loadFactor; &#125; Segment定义final Segment&lt;K,V&gt;[] segments; 默认Segment的并发级别为16static final int DEFAULT_CONCURRENCY_LEVEL = 16; JDK 1.8 的改动JDK1.7使用Segment分段锁机制来实现并发更新操作，核心类即Segment,继承自重入锁ReentrantLock,并发度等于Segment个数。 JDK1.8中使用CAS操作来支持更高的并发度，在CAS操作失败时使用内置锁synchronized，同样在链表过长时会转换为红黑树。 LinkedHashMap存储结构：继承自HashMap,因此具有和HashMap一样的快速查找特性。 内部维护一个双向链表，用来维护插入顺序或者LRU顺序。/** * The head (eldest) of the doubly linked list. */ transient LinkedHashMap.Entry&lt;K,V&gt; head; /** * The tail (youngest) of the doubly linked list. */ transient LinkedHashMap.Entry&lt;K,V&gt; tail; accessOrder决定了顺序，默认为false,此时维护的是插入顺序 final boolean accessOrder; LinkedHashMap最重要的是以下两个维护顺序的函数，会在put、get等方法中调用。 void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125; void afterNodeInsertion(boolean evict) &#123; &#125; afterNodeAccess()当一个节点被访问时，如果accessOrder为true,则会把这个节点移到链表尾部。即指定了LRU顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，链表首部是最久没访问的节点。 afterNodeInsertion()put操作等操作之后执行，当removeOldestEntry（）为true时，会移除链表首部节点first removeOldestEntry默认为false,如果要让它为true,需继承自LinkedHashMap并覆盖这个方法的实现。这是实现LRU缓存的核心，移除最近最久未使用的节点，保证缓存空间足够，并且缓存的数据都是热点数据。 实现LRU缓存的思路a.继承LinkedHashMap b.使用LinkedHashMap构造函数将accessOrder设置为true,开启LRU顺序。 c.覆盖removeOldestEntry（）实现，在节点多余MAX_ENTRY时，方法返回true，删除最近最久未使用的节点。 class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123; private static final int MAX_ENTRIES = 3; protected boolean removeEldestEntry(Map.Entry eldest) &#123; return size() &gt; MAX_ENTRIES; &#125; LRUCache() &#123; super(MAX_ENTRIES, 0.75f, true); &#125; &#125; public static void main(String[] args) &#123; LRUCache&lt;Integer, String&gt; cache = new LRUCache&lt;&gt;(); cache.put(1, &quot;a&quot;); cache.put(2, &quot;b&quot;); cache.put(3, &quot;c&quot;); cache.get(1); cache.put(4, &quot;d&quot;); System.out.println(cache.keySet()); &#125; [3,1,4] WeakHashMap存储结构WeakHashMap的Entry继承自WeakReference,被weakReference关联的对象在下一次垃圾回收时会被回收。 WeakHashMap主要用来实现缓存，通过使用WeakHashMap来引用缓存对象，由JVM对这部分缓存进行回收。 private static class Entry&lt;K,V&gt; extends WeakReference&lt;Object&gt; implements Map.Entry&lt;K,V&gt; ConcurrentCacheTomcat中的ConcurrentCache使用了WeakHashMap来实现缓存功能。 ConcurrentCache采取的是分代缓存： 经常使用的对象放入eden中，eden用ConcurrentHashMap实现，不用担心会被回收。 不常用的放入longterm,longterm使用WeakHashMap实现，这些老对象会被垃圾回收器回收。 当调用get()时，先从eden获取，如果没有再到longterm获取，如果从longterm获取到就放入 eden中，保证经常被访问的节点不会被回收。 当调用put()时，如果eden的大小超过了size，那么将eden的所有对象都放入longterm中，利用虚拟机回收掉一部分不经常使用的对象。 public final class ConcurrentCache&lt;K, V&gt; &#123; private final int size; private final Map&lt;K, V&gt; eden; private final Map&lt;K, V&gt; longterm; public ConcurrentCache(int size) &#123; this.size = size; this.eden = new ConcurrentHashMap&lt;&gt;(size); this.longterm = new WeakHashMap&lt;&gt;(size); &#125; public V get(K k) &#123; V v = this.eden.get(k); if (v == null) &#123; v = this.longterm.get(k); if (v != null) this.eden.put(k, v); &#125; return v; &#125; public void put(K k, V v) &#123; if (this.eden.size() &gt;= size) &#123; this.longterm.putAll(this.eden); this.eden.clear(); &#125; this.eden.put(k, v); &#125; &#125;]]></content>
      <categories>
        <category>-list -set -map</category>
      </categories>
      <tags>
        <tag>-容器 -list -set -map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的代理机制]]></title>
    <url>%2F2019%2F08%2F08%2FJava%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1.静态代理​ 创建一个接口，被代理类实现该接口并实现该接口的抽象方法，代理类也实现该接口，即代理类与被代理类实现同一接口。代理类中持有被代理类的引用，即被代理类是代理类的成员变量，在代理类实现的接口方法中调用被代理类的方法。 ​ 其实就是代理类为被代理类预处理消息、过滤消息后执行被代理类，并能进行消息的后置处理。代理类与被代理类通常存在关联关系（持有被代理对象的引用）。代理类通过调用被代理类中方法提供服务。 ​ 静态代理示例 接口：​ public interface ProxyInterface &#123; void excute(); &#125; 被代理类：/** * @author dumboj * 被代理类 * */ public class ByProxy implements ProxyInterface &#123; @Override public void excute() &#123; System.out.println(&quot;The Class which implements ProxyInterface excute... ...&quot;); &#125; &#125; 代理类：/*** * @author dumboj 静态代理类---与被代理实现相同接口 */ public class ProxyClass implements ProxyInterface &#123; // 成员变量--接口 private ProxyInterface proxy; // 构造方法多态赋值 public ProxyClass() &#123; proxy = new ByProxy(); &#125; @Override public void excute() &#123; System.out.println(&quot;Do something before ByProxy Class excute&quot;); proxy.excute(); System.out.println(&quot;Do something before ByProxy Class excute&quot;); &#125; &#125; 测试类：/** * @author dumboj 测试静态代理调用 */ public class StaticProxyTest &#123; public static void main(String[] args) &#123; ProxyInterface proxy = new ProxyClass(); proxy.excute(); &#125; &#125; 执行结果：Do something before ByProxy Class excute The Class which implements ProxyInterface excute... ... Do something after ByProxy Class excute ​ 由上知，静态代理很容易对单个类实现代理。缺点在于，静态代理只能为一个类服务，当需要代理的类增加，需编写大量代理类，工作量繁重。 ​ 静态代理直接通过编码创建代理类。 2.JDK动态代理接口：/** * @author dumboj * * */ public interface MobilePhone &#123; void call(); &#125; 被代理类：/** * @author dumboj * */ public class IOSMobilePhone implements MobilePhone &#123; private String firstName; private String lastName; public IOSMobilePhone(String firstName, String lastName) &#123; super(); this.firstName = firstName; this.lastName = lastName; &#125; @Override public void call() &#123; System.out.println(&quot;use apple phone call the &quot;+firstName+&quot;·&quot;+lastName); &#125; &#125; InvocationHandler–每个代理对象都会关联一个InvocationHandler/** * @author dumboj * */ public class MobilePhoneHandler&lt;T&gt; implements InvocationHandler &#123; //持有被代理对象引用 private T target; public MobilePhoneHandler(T target) &#123; super(); this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //前置方法 before(); Object obj = method.invoke(target, args); //后置方法 after(); return obj; &#125; private void after() &#123; System.out.println(&quot;method after target method invok ...&quot;); &#125; private void before() &#123; System.out.println(&quot;method before target method invok ...&quot;); &#125; &#125; 测试类/** * @author dumboj * */ public class ProxyIOSMobileTest &#123; public static void main(String[] args) &#123; MobilePhone mobile = new IOSMobilePhone(&quot;LeBron&quot;, &quot;James&quot;); InvocationHandler handler = new MobilePhoneHandler&lt;MobilePhone&gt;(mobile); MobilePhone mpProxy = (MobilePhone)Proxy.newProxyInstance(mobile.getClass().getClassLoader(), new Class&lt;?&gt;[] &#123;MobilePhone.class&#125;, handler); mpProxy.call(); &#125; &#125; 执行结果method before target method invok ... use apple phone call the LeBron·James method after target method invok ... Java的动态代理中，IncocationHandler和Proxy是两个重要的类或接口。 Java API中的描述： InvocationHandler InvocationHandler is the interface implemented by the invocation handler of a proxy instance. Each proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler. 每一个动态代理类都必须实现InvocaitonHandler接口，每个代理类的实例都关联到一个Handler,当我们通过代理对象调用一个方法时，这个方法的调用会被转发为由InvocationHandler这个接口的invoke（）调用。 Object invoke(Object proxy, Method method, Object[] args) throws Throwable proxy: 指代我们所代理的那个真实对象 method: 指代的是我们所要调用真实对象的某个方法的Method对象 args: 指代的是调用真实对象某个方法时接受的参数 Proxy这个类的作用则是用来动态创建一个代理对象的类，关键看newProxyInstance()这个方法。 public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException Returns an instance of a proxy class for the specified interfaces that dispatches method invocations to the specified invocation handler. 这个方法的作用就是得到一个动态的代理对象，其中三个参数的含义： ClassLoader loader一个ClassLoader类加载器对象，定义由哪个类加载对生成的代理对象进行加载。 Class&lt;?&gt;[] interfaces一个接口对象的数组，表示将要给被代理的对象提供一组什么接口，如果提供一个被代理类的接口对象，则认为代理对象和被代理对象实现了统一接口（多态），这样就能调用这组接口中的方法了。 InvocationHandler h一个InvocationHandler 对象，表示被代理对象在调用方法时，会关联到哪一个InvocationHandler对象上。 动态代理与静态代理区别 ：1.Proxy类的代码固定，不因业务庞大而需要是维护很多代理类。 2.可以实现AOP编程 3.解耦，web业务下可以实现数据层和业务层的分离 4.无侵入式代码扩展]]></content>
      <categories>
        <category>-动态代理</category>
      </categories>
      <tags>
        <tag>-java -JDK动态代理 -CGLIB动态代理 -静态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ElasticSearch安装]]></title>
    <url>%2F2019%2F08%2F01%2FElasticSearch%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Elasticsearch安装安装准备： 环境 版本 说明 link windows 7 elasticsrarch 7.3.0 https://www.elastic.co/cn/downloads/elasticsearch elasticsearch-head git仓库master，可视化界面 ssh:&#103;&#x69;&#x74;&#x40;&#x67;&#x69;&#116;&#x68;&#117;&#98;&#x2e;&#99;&#x6f;&#109;:mobz/elasticsearch-head.githttps:https://github.com/mobz/elasticsearch-head.gitChrome插件 nodejs v10.16.0 es-head运行环境 http://nodejs.cn/download JDK 1.8 es运行环境 1.elasticsearch解压 bin目录下elasticsearch.bat可执行文件启动es服务 2.elasticsearch-head目录下打开cmd窗口 ​ 执行以下命令 npm install -g grunt-cli npm install grunt server Started connect web server on http://localhost:9100 --可视化服务启动 3.localhost:9100访问可视化界面 http://localhost:9200/服务连接不上，修改ES安装目录下 /config/elasticsearch.yml 添加： http.cors.enabled: true http.cors.allow-origin: &quot;*&quot; 重启es服务，访问可视化界面，成功连接链接http://localhost:9200/]]></content>
      <categories>
        <category>-elasticsearch</category>
      </categories>
      <tags>
        <tag>-elasticsearch环境安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node升级]]></title>
    <url>%2F2019%2F07%2F25%2Fnode%E5%8D%87%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[npm 升级npm i -g npm 升级npm版本 也可以指定npm版本号： npm i -g npm@6.10.1 node 升级 通过npm安装node的版本管理工具 n npm i -g n ` Commands: n Output versions installed --查看已安装版本 n latest Install or activate the latest node release --最新版本 n -a x86 latest As above but force 32 bit architecture n stable Install or activate the latest stable node release --安装稳定版 n lts Install or activate the latest LTS node release n &lt;version&gt; Install node &lt;version&gt; --安装指定版本 n use &lt;version&gt; [args ...] Execute node &lt;version&gt; with [args ...] n bin &lt;version&gt; Output bin path for &lt;version&gt; n rm &lt;version ...&gt; Remove the given version(s) n prune Remove all versions except the current version n --latest Output the latest node version available n --stable Output the latest stable node version available n --lts Output the latest LTS node version available n ls Output the versions of node available souce /etc/profile node -v npm -v]]></content>
      <categories>
        <category>-nodejs</category>
      </categories>
      <tags>
        <tag>-npm -n -nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitCommand]]></title>
    <url>%2F2019%2F07%2F22%2FgitKnowledge%2F</url>
    <content type="text"><![CDATA[git分布式版本控制工具有趣的学习git 创建版本库:​ $ mk dir folder_name ​ $ cd folder_name ​ $ pwd $ git init 添加文件后将文件添加到受git管理的文件​ $ git add file_name ​ $ git commit -m &quot;discribe&quot; 修改文件后查看版本库状态/文件修改查看​ $ git status ​ $ git diff 确认修改内容后重复add-commit文件提交版本库​ git status命令掌握工作区的状态。 ​ 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 查看HEAD指向cat .git/HEAD git symbolic-ref HEAD --如果HEAD指向的是一个引用 二 版本控制及文件操作1.版本回退​ $ git reset --hard HEAD^ ​ $ git reset --hard HEAD^ ​ $ git reset --hard HEAD~? ​ $ git reset --hard commit_ID ​ $ git reflog ​ $ git log ​ $ git log --pretty=oneline 2.工作区VS暂存区​ git add 将工作区修改和新加的文件添加到暂存区 ​ git commit 将暂存区文件一次性提交到分支 3.管理修改​ git跟踪文件修改，每次修改若不用git add 添加到暂存区，就不会加入到commit中。 ​ $ cat fie_name ​ 修改文件内容 ​ $ git add file_name ​ 修改文件内容 ​ $ git commit -m file_name ​ $ git status ​ $ git diff HEAD -- file_name 命令可以查看工作区和版本库里面最新版本的区别 4.撤销修改方式1：git reset HEAD~X ​ 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 ​ 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步， 第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。 ​ 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，前提是没有推送到远程库。使用 ​ $ git reset --hard commit_ID($ git reset --hard HEAD^/HEAD^^/HEAD~?–？为数字) 方式2：git revert HEAD​ 通过下图的图形化可以看到，revert方式并不是像reset回退到某个提交记录，而是在撤销的提交记录后面添加一个新提交，这个提交引入了更改，这个更改刚好是用来撤销目标提交的。也就是添加的新纪录C2’的状态与C1是相同的。 revert前远程分支状态 ​ revert后远程分支状态 ​ 5.删除文件​ 场景一：已提交版本库，误删本地文件，需要恢复 ​ $ git checkout -- file_name 时其实是将版本库的版本替换工作区的版本，所以，无论工作区是修改还是删除都 可以还原 ​ 场景二：工作区要删除文件已提交至版本库（本地非远程） ​ $ git rm file_name ​ $ git commit ​ 注意：从本地版本库恢复的文件会丢失最近一次提交后修改的内容。 6.整理提交记录1.git cherry-pick 提交号 ps.使用于知道提交的哈希值时​ 例如，现有两个分支，HEAD指向当前分支master ​ ​ 我们只需要C2、C4两次提交的内容，命令： git cherry-pick C2 C4 ​ 整理后： ​ 2.交互式的rebase(git rebase -interactive ) +某个已知提交点 —ps.使用于不清楚具体提交的哈希值时​ 从一系列的提交记录中找到想要的记录，选择HEAD前的某个已知提交，该提交最好是HEAD和提取分支的共 同父节点，并通过切换pick状态来控制提交;交互式的rebase通过鼠标来修改提交记录的顺序。 7.本地栈式提交​ 三 远程仓库1.推送到远程仓库​ $ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 生成公钥,在github添加 ​ $ git remote add origin git@github.com:DumboJ/LxfGit.git ​ 关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； ​ 关联后，使用命令git push -u origin master第一次推送master分支的所有内容(-u参数，Git不但会把本地的 master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令) ​ 注:首次提交时版本库并没有远程仓库中的README.md文件, 在push前先执行 git pull --rebase origin master ​ 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 从远程库克隆要克隆一个仓库，确认仓库地址，然后使用git clone命令克隆。 不指定分支： git + clone + clone_address 例：git clone git@github.com:Dumboj/DmboJ.github.io.git 指定分支： git + clone + -b + branch_name + clone_address 例：git clone -b hexo git@github.com:Dumboj/DmboJ.github.io.git Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。 四 分支管理每次提交,git 都串成一条时间线.git 的分支指向提交,HEAD指向当前分支. 分离HEAD概念：HEAD不指向分支而是某个具体的提交 ​ 用途：强制修改分支位置 ​ 方式1.git branch -f master C1 强制将master分支指向C1 方式2.git branch -f master HEAD~3 Git鼓励大量使用分支：查看分支：git branch 创建分支：git branch &lt;name&gt; ​ 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 1.创建与合并分支①:创建分支​ A-$ git branch branch_name ​ B- $ git checkout branch_name ​ C- $ git push origin branch_name ​ 相当于 $ git checkout -b branch_name ​ $ git branch -a ②合并分支​ git merge branch_name ③删除分支​ $ git branch -d branch_name 2.解决冲突​ 当前分支和合并分支操作相同文件都提交,合并时会造成冲突 ​ 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 ​ 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。 ​ 用git log --graph命令可以看到分支合并图。 3.分支管理策略​ 合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 ​ 合并分支时,不用Fast forward模式,则 $ git merge --no-ff -m &quot;merge with no-ff&quot; branch_name ​ 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 4.bug分支​ 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； ​ 先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 ​ $ git stash list 可以查看stash内容. ​ 工作现场恢复方式 ​ A.$ git stash apply 恢复,恢复后,stash 内容并不删除,需要用git stash drop来删除. ​ B.$ git stash pop 恢复的同时把stash内容也删了. 5.Feature 分支​ 开发一个新feature，最好新建一个分支； ​ 如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除。 6.多人协作​ 推送分支,实际就是将分支上的所有本地提交推送到远程库.推送时,指定本地分支,这样,git 就会把该分支推送到远程库对应的远程分支上: ​ $ git push origin branch_name ​ $ git clone git@github.com:user_name/respository_name.git 首先，可以试图用git push origin &lt;branch-name&gt;推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt; 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 7.rebase rebase操作可以把本地未push的分叉提交历史整理成直线； rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。 五.标签管理1.创建标签​ 命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id； ​ 命令git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息； ​ 命令git tag可以查看所有标签。 2.操作标签​ 命令git push origin &lt;tagname&gt;可以推送一个本地标签； ​ 命令git push origin --tags可以推送全部未推送过的本地标签； ​ 命令git tag -d &lt;tagname&gt;可以删除一个本地标签； ​ 命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。 SSH 传输设置Git 仓库和 Github 中心仓库之间的传输是通过 SSH 加密。 如果工作区下没有 .ssh 目录，或者该目录下没有 id_rsa 和 id_rsa.pub 这两个文件，可以通过以下命令来创建 SSH Key： $ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 然后把公钥 id_rsa.pub 的内容复制到 Github “Account settings” 的 SSH Keys 中。 .gitignore 文件忽略以下文件： 操作系统自动生成的文件，比如缩略图； 编译生成的中间文件，比如 Java 编译产生的 .class 文件； 自己的敏感信息，比如存放口令的配置文件。 不需要全部自己编写，可以到 https://github.com/github/gitignore 中进行查询。 Git 命令一览 比较详细的地址：http://www.cheat-sheets.org/saved-copy/git-cheat-sheet.pdf]]></content>
      <categories>
        <category>-git</category>
      </categories>
      <tags>
        <tag>-git -VersionControl</tag>
      </tags>
  </entry>
</search>
